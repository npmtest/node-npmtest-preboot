{"/home/travis/build/npmtest/node-npmtest-preboot/test.js":"/* istanbul instrument in package npmtest_preboot */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-preboot/lib.npmtest_preboot.js":"/* istanbul instrument in package npmtest_preboot */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_preboot = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_preboot = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-preboot/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-preboot && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_preboot */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_preboot\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_preboot.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_preboot.rollup.js'] =\n            local.assetsDict['/assets.npmtest_preboot.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_preboot.__dirname + '/lib.npmtest_preboot.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-preboot/node_modules/preboot/__build/src/node/preboot_node.js":"\"use strict\";\nvar preboot_inline_1 = require('../inline/preboot_inline');\nvar preboot_browser_1 = require('../browser/preboot_browser');\nvar fs = require('fs');\nvar path = require('path');\nvar inlineCodeCache = {};\n// exporting default options in case developer wants to use these + custom on top\nexports.defaultOptions = {\n    buffer: true,\n    // these are the default events are are listening for an transfering from server view to client view\n    eventSelectors: [\n        // for recording changes in form elements\n        { selector: 'input,textarea', events: ['keypress', 'keyup', 'keydown', 'input', 'change'] },\n        { selector: 'select,option', events: ['change'] },\n        // when user hits return button in an input box\n        { selector: 'input', events: ['keyup'], preventDefault: true, keyCodes: [13], freeze: true },\n        // for tracking focus (no need to replay)\n        { selector: 'input,textarea', events: ['focusin', 'focusout', 'mousedown', 'mouseup'], noReplay: true },\n        // user clicks on a button\n        { selector: 'input[type=\"submit\"],button', events: ['click'], preventDefault: true, freeze: true }\n    ]\n};\n/**\n * Deprecated function just used for backward compatibility.\n * note that certian older options for preboot like listen, replay, freeze, etc. are no longer available\n *\n * @param legacyOptions Object that contains legacy preboot options\n */\nfunction getBrowserCode(legacyOptions) {\n    legacyOptions = legacyOptions || {};\n    // we will remove this function with the next version\n    console.warn('getBrowserCode() deprecated and many custom options no longer available. ' +\n        'Please switch to getInlineCode().');\n    var inlineCode = getInlineCode({\n        appRoot: legacyOptions.appRoot || 'app',\n        uglify: legacyOptions.uglify,\n        buffer: legacyOptions.buffer,\n        noInlineCache: legacyOptions.noInlineCache,\n        eventSelectors: legacyOptions.eventSelectors,\n        serverClientRoot: legacyOptions.serverClientRoot\n    });\n    // two different possibilities depending on how client is calling preboot_node\n    var minCodePath = path.normalize(__dirname + '/../../../__dist/preboot_browser.min.js');\n    var browserCode = (legacyOptions.uglify && fs.existsSync(minCodePath)) ?\n        fs.readFileSync(minCodePath).toString() :\n        (preboot_browser_1.prebootClient.toString() + '\\nvar preboot = prebootClient();');\n    var deprecatedCode = inlineCode + '\\n' + browserCode;\n    return Promise.resolve(deprecatedCode);\n}\nexports.getBrowserCode = getBrowserCode;\n/**\n * Main entry point for the server side version of preboot. The main purpose\n * is to generate inline code that can be inserted into the server view.\n *\n * @param customOptions PrebootOptions that override the defaults\n * @returns {string} Generated inline preboot code is returned\n */\nfunction getInlineCode(customOptions) {\n    var opts = assign({}, exports.defaultOptions, customOptions);\n    // safety check to make sure options passed in are valid\n    validateOptions(opts);\n    // as long as we inline code caching isn't disabled and exists in cache, use the cache\n    var optsKey = JSON.stringify(opts);\n    if (!opts.noInlineCache && inlineCodeCache[optsKey]) {\n        return inlineCodeCache[optsKey];\n    }\n    // two different possibilities depending on how client is calling preboot_node\n    var minCodePath = path.normalize(__dirname + '/../../../__dist/preboot_inline.min.js');\n    var inlineCode = (opts.uglify && fs.existsSync(minCodePath)) ?\n        fs.readFileSync(minCodePath).toString() :\n        preboot_inline_1.prebootstrap.toString();\n    // generate the inline JavaScript from prebootstrap\n    inlineCode += '\\n ' + 'prebootstrap().init(' + stringifyWithFunctions(opts) + ');';\n    // cache results as long as caching not disabled\n    if (!opts.noInlineCache) {\n        inlineCodeCache[optsKey] = inlineCode;\n    }\n    return inlineCode;\n}\nexports.getInlineCode = getInlineCode;\n/**\n * Throw an error if issues with any options\n * @param opts\n */\nfunction validateOptions(opts) {\n    if ((!opts.appRoot || !opts.appRoot.length) &&\n        (!opts.serverClientRoot || !opts.serverClientRoot.length)) {\n        throw new Error('The appRoot is missing from preboot options. ' +\n            'This is needed to find the root of your application. ' +\n            'Set this value in the preboot options to be a selector for the root element of your app.');\n    }\n}\n/**\n * For some reason, Object.assign() is not fully supporting in TypeScript, so\n * this is just a simple implementation of it\n *\n * @param target The target object\n * @param optionSets Any number of addition objects that are added on top of the target\n * @returns {Object} A new object that contains all the merged values\n */\nfunction assign(target) {\n    var optionSets = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        optionSets[_i - 1] = arguments[_i];\n    }\n    if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n    }\n    var output = Object(target);\n    for (var index = 0; index < optionSets.length; index++) {\n        var source = optionSets[index];\n        if (source !== undefined && source !== null) {\n            for (var nextKey in source) {\n                if (source.hasOwnProperty(nextKey)) {\n                    output[nextKey] = source[nextKey];\n                }\n            }\n        }\n    }\n    return output;\n}\nexports.assign = assign;\n/**\n * Stringify an object and include functions. This is needed since we are letting\n * users pass in options that include custom functions for things like the\n * freeze handler or action when an event occurs\n *\n * @param obj This is the object you want to stringify that includes some functions\n * @returns {string} The stringified version of an object\n */\nfunction stringifyWithFunctions(obj) {\n    var FUNC_START = 'START_FUNCTION_HERE';\n    var FUNC_STOP = 'STOP_FUNCTION_HERE';\n    // first stringify except mark off functions with markers\n    var str = JSON.stringify(obj, function (key, value) {\n        // if the value is a function, we want to wrap it with markers\n        if (!!(value && value.constructor && value.call && value.apply)) {\n            return FUNC_START + value.toString() + FUNC_STOP;\n        }\n        else {\n            return value;\n        }\n    });\n    // now we use the markers to replace function strings with actual functions\n    var startFuncIdx = str.indexOf(FUNC_START);\n    var stopFuncIdx, fn;\n    while (startFuncIdx >= 0) {\n        stopFuncIdx = str.indexOf(FUNC_STOP);\n        // pull string out\n        fn = str.substring(startFuncIdx + FUNC_START.length, stopFuncIdx);\n        fn = fn.replace(/\\\\n/g, '\\n');\n        str = str.substring(0, startFuncIdx - 1) + fn + str.substring(stopFuncIdx + FUNC_STOP.length + 1);\n        startFuncIdx = str.indexOf(FUNC_START);\n    }\n    return str;\n}\nexports.stringifyWithFunctions = stringifyWithFunctions;\n","/home/travis/build/npmtest/node-npmtest-preboot/node_modules/preboot/__build/src/inline/preboot_inline.js":"/**\n * This is the entire inline JavaScript used for preboot. The way it works is that\n * the server side library for preboot calls toString() on the prebootstrap() function\n * and then injects the resulting JavaScript directly into the server view.\n *\n * As a result, all the code must be within the one prebootstrap() function and it\n * can't use any external dependencies other than interfaces.\n *\n * The final result of this code is to have a global object called prebootData which\n * hangs off the window and can be accessed by the preboot client code to replay\n * events, switch buffers and facilitate the switch from server view to client view.\n */\n\"use strict\";\n/**\n * The purpose of this wrapper function is simply to have an easy way for the preboot node\n * library to generate the inline code without any downstream deps (like webpack). Basically,\n * the node library get this JavaScript by calling prebootstrap.toString() then it adds\n *\n * prebootstrap().init(opts);\n */\nfunction prebootstrap() {\n    var CARET_EVENTS = ['keyup', 'keydown', 'focusin', 'mouseup', 'mousedown'];\n    var CARET_NODES = ['INPUT', 'TEXTAREA'];\n    var prebootStarted = false;\n    /**\n     * Called right away to initialize preboot\n     *\n     * @param opts All the preboot options\n     */\n    function init(opts) {\n        // we allow for window to be passed in so we can unit test on the server side\n        var theWindow = (opts.window || window);\n        // add the preboot options to the preboot data and then add the data to\n        // the window so it can be used later by the client\n        var data = theWindow.prebootData = {\n            opts: opts,\n            listening: true,\n            apps: [],\n            listeners: []\n        };\n        // start up preboot listening as soon as the DOM is ready\n        waitUntilReady(data);\n    }\n    /**\n     * We want to attach event handlers as soon as possible. Unfortunately this means before\n     * DOMContentLoaded fires, so we need to look for document.body to exist instead.\n     * @param data\n     */\n    function waitUntilReady(data) {\n        var theWindow = (data.opts.window || window);\n        var document = (theWindow.document || {});\n        if (document.body) {\n            start(document, data);\n        }\n        else {\n            setTimeout(function () {\n                waitUntilReady(data);\n            }, 10);\n        }\n        // in most cases we wait until DOMContentLoaded, but if the document is ready, start NOW!\n        // if (document.readyState === 'interactive') {\n        //   start(document, data);\n        // } else {\n        //   document.addEventListener('DOMContentLoaded', () => start(document, data));\n        // }\n    }\n    /**\n     * Start up preboot by going through each app and assigning the appropriate handlers.\n     * Normally this wouldn't be called directly, but we have set it up so that it can\n     * for older versions of Universal.\n     *\n     * @param document Global document object passed in for testing purposes\n     * @param prebootData Global preboot data object that contains options and will have events\n     */\n    function start(document, prebootData) {\n        // only start once\n        if (prebootStarted) {\n            return;\n        }\n        else {\n            prebootStarted = true;\n        }\n        // hack to tslint; otherwise typescript complains about window.prebootData\n        /* tslint:disable: no-string-literal */\n        prebootData = (prebootData || window['prebootData']);\n        document = (document || window.document);\n        var opts = prebootData.opts || {};\n        var eventSelectors = opts.eventSelectors || [];\n        // create an overlay that can be used later if a freeze event occurs\n        prebootData.overlay = createOverlay(document);\n        // get an array of all the root info\n        var appRoots = getAppRoots(document, prebootData.opts);\n        // for each app root\n        appRoots.forEach(function (root) {\n            // we track all events for each app in the prebootData object which is on the global scope\n            var appData = { root: root, events: [] };\n            prebootData.apps.push(appData);\n            // loop through all the eventSelectors and create event handlers\n            eventSelectors.forEach(function (eventSelector) { return handleEvents(prebootData, appData, eventSelector); });\n        });\n    }\n    /**\n     * Create an overlay div and add it to the DOM so it can be used\n     * if a freeze event occurs\n     *\n     * @param document The global document object (passed in for testing purposes)\n     * @returns Element The overlay node is returned\n     */\n    function createOverlay(document) {\n        var overlay = document.createElement('div');\n        overlay.setAttribute('id', 'prebootOverlay');\n        overlay.setAttribute('style', 'display:none;position:absolute;left:0;' +\n            'top:0;width:100%;height:100%;z-index:999999;background:black;opacity:.3');\n        document.body.appendChild(overlay);\n        return overlay;\n    }\n    /**\n     * Get references to all app root nodes based on input options. Users can initialize preboot\n     * either by specifying appRoot which is just one or more selectors for apps, or if you want\n     * to get more complex they can pass in the serverClientRoot option which contains selectors\n     * for both the client and the server. This section option is useful for people that are\n     * doing their own buffering (i.e. they have their own client and server view)\n     *\n     * @param document The global document object passed in for testing purposes\n     * @param opts Options passed in by the user to init()\n     * @returns ServerClientRoot[] An array of root info for each app\n     */\n    function getAppRoots(document, opts) {\n        var roots = (opts.serverClientRoot || []);\n        // loop through any appRoot selectors to add them to the list of roots\n        if (opts.appRoot && opts.appRoot.length) {\n            var appRootSelectors = [].concat(opts.appRoot);\n            appRootSelectors.forEach(function (selector) { return roots.push({ serverSelector: selector }); });\n        }\n        // now loop through the roots to get the nodes for each root\n        roots.forEach(function (root) {\n            root.serverNode = document.querySelector(root.serverSelector);\n            root.clientSelector = root.clientSelector || root.serverSelector;\n            if (root.clientSelector !== root.serverSelector) {\n                // if diff selectors, then just get the client node\n                root.clientNode = document.querySelector(root.clientSelector);\n            }\n            else if (opts.buffer) {\n                // if we are doing buffering, we need to create the buffer for the client\n                root.clientNode = createBuffer(root);\n            }\n            else {\n                // else the client root is the same as the server\n                root.clientNode = root.serverNode;\n            }\n            // if no server node found, log error\n            if (!root.serverNode) {\n                console.log('No server node found for selector: ' + root.serverSelector);\n            }\n        });\n        return roots;\n    }\n    /**\n     * Under given server root, for given selector, record events\n     *\n     * @param prebootData\n     * @param appData\n     * @param eventSelector\n     */\n    function handleEvents(prebootData, appData, eventSelector) {\n        var serverRoot = appData.root.serverNode;\n        // don't do anything if no server root\n        if (!serverRoot) {\n            return;\n        }\n        // get all nodes under the server root that match the given selector\n        var nodes = serverRoot.querySelectorAll(eventSelector.selector);\n        // don't do anything if no nodes found\n        if (!nodes) {\n            return;\n        }\n        // we want to add an event listener for each node and each event\n        var _loop_1 = function(node) {\n            eventSelector.events.forEach(function (eventName) {\n                // get the appropriate handler and add it as an event listener\n                var handler = createListenHandler(prebootData, eventSelector, appData, node);\n                node.addEventListener(eventName, handler);\n                // need to keep track of listeners so we can do node.removeEventListener() when preboot done\n                prebootData.listeners.push({\n                    node: node,\n                    eventName: eventName,\n                    handler: handler\n                });\n            });\n        };\n        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n            var node = nodes_1[_i];\n            _loop_1(node);\n        }\n    }\n    /**\n     * Create handler for events that we will record\n     */\n    function createListenHandler(prebootData, eventSelector, appData, node) {\n        return function (event) {\n            var root = appData.root;\n            var eventName = event.type;\n            // if no node or no event name or not listening, just return\n            if (!node || !eventName) {\n                return;\n            }\n            // if key codes set for eventSelector, then don't do anything if event doesn't include key\n            var keyCodes = eventSelector.keyCodes;\n            if (keyCodes && keyCodes.length) {\n                var matchingKeyCodes = keyCodes.filter(function (keyCode) { return event.which === keyCode; });\n                // if there are not matches (i.e. key entered NOT one of the key codes) then don't do anything\n                if (!matchingKeyCodes.length) {\n                    return;\n                }\n            }\n            // if for a given set of events we are preventing default, do that\n            if (eventSelector.preventDefault) {\n                event.preventDefault();\n            }\n            // if an action handler passed in, use that\n            if (eventSelector.action) {\n                eventSelector.action(node, event);\n            }\n            // get the node key for a given node\n            var nodeKey = getNodeKey({ root: root, node: node });\n            // if event on input or text area, record active node\n            if (CARET_EVENTS.indexOf(eventName) >= 0 && CARET_NODES.indexOf(node.tagName) >= 0) {\n                prebootData.activeNode = {\n                    root: root,\n                    node: node,\n                    nodeKey: nodeKey,\n                    selection: getSelection(node)\n                };\n            }\n            else if (eventName !== 'change' && eventName !== 'focusout') {\n                ;\n                prebootData.activeNode = null;\n            }\n            // if we are freezing the UI\n            if (eventSelector.freeze) {\n                var overlay_1 = prebootData.overlay;\n                // show the overlay\n                overlay_1.style.display = 'block';\n                // hide the overlay after 10 seconds just in case preboot.complete() never called\n                setTimeout(function () {\n                    overlay_1.style.display = 'none';\n                }, 10000);\n            }\n            // we will record events for later replay unless explicitly marked as doNotReplay\n            if (!eventSelector.noReplay) {\n                appData.events.push({\n                    node: node,\n                    nodeKey: nodeKey,\n                    event: event,\n                    name: eventName\n                });\n            }\n        };\n    }\n    /**\n     * Attempt to generate key from node position in the DOM\n     *\n     * NOTE: this function is duplicated in preboot_browser.ts and must be\n     * kept in sync. It is duplicated for right now since we are trying\n     * to keep all inline code separated and distinct (i.e. without imports)\n     */\n    function getNodeKey(nodeContext) {\n        var ancestors = [];\n        var root = nodeContext.root;\n        var node = nodeContext.node;\n        var temp = node;\n        // walk up the tree from the target node up to the root\n        while (temp && temp !== root.serverNode && temp !== root.clientNode) {\n            ancestors.push(temp);\n            temp = temp.parentNode;\n        }\n        // note: if temp doesn't exist here it means root node wasn't found\n        if (temp) {\n            ancestors.push(temp);\n        }\n        // now go backwards starting from the root, appending the appName to unique identify the node later..\n        var name = node.nodeName || 'unknown';\n        var key = name + '_' + root.serverSelector;\n        var len = ancestors.length;\n        for (var i = (len - 1); i >= 0; i--) {\n            temp = ancestors[i];\n            if (temp.childNodes && i > 0) {\n                for (var j = 0; j < temp.childNodes.length; j++) {\n                    if (temp.childNodes[j] === ancestors[i - 1]) {\n                        key += '_s' + (j + 1);\n                        break;\n                    }\n                }\n            }\n        }\n        return key;\n    }\n    /**\n     * Get the selection data that is later used to set the cursor after client view is active\n     */\n    function getSelection(node) {\n        node = node || {};\n        var nodeValue = node.value || '';\n        var selection = {\n            start: nodeValue.length,\n            end: nodeValue.length,\n            direction: 'forward'\n        };\n        // if browser support selectionStart on node (Chrome, FireFox, IE9+)\n        try {\n            if (node.selectionStart || node.selectionStart === 0) {\n                selection.start = node.selectionStart;\n                selection.end = node.selectionEnd;\n                selection.direction = node.selectionDirection;\n            }\n        }\n        catch (ex) { }\n        return selection;\n    }\n    /**\n     * Create buffer for a given node\n     *\n     * @param root All the data related to a particular app\n     * @returns {Element} Returns the root client node.\n     */\n    function createBuffer(root) {\n        var serverNode = root.serverNode;\n        // if no rootServerNode OR the selector is on the entire html doc or the body OR no parentNode, don't buffer\n        if (!serverNode || !serverNode.parentNode ||\n            root.serverSelector === 'html' || root.serverSelector === 'body') {\n            return serverNode;\n        }\n        // create shallow clone of server root\n        var rootClientNode = serverNode.cloneNode(false);\n        if (rootClientNode) {\n            // we want the client to write to a hidden div until the time for switching the buffers\n            rootClientNode.style.display = 'none';\n            // insert the client node before the server and return it\n            serverNode.parentNode.insertBefore(rootClientNode, serverNode);\n        }\n        // return the rootClientNode\n        return rootClientNode;\n    }\n    // return object with all the functions for testing purposes\n    return {\n        init: init,\n        start: start,\n        createOverlay: createOverlay,\n        getAppRoots: getAppRoots,\n        handleEvents: handleEvents,\n        createListenHandler: createListenHandler,\n        getNodeKey: getNodeKey,\n        getSelection: getSelection,\n        createBuffer: createBuffer\n    };\n}\nexports.prebootstrap = prebootstrap;\n","/home/travis/build/npmtest/node-npmtest-preboot/node_modules/preboot/__build/src/browser/preboot_browser.js":"/**\n * This is the entry point for the client side preboot library. At a high level, this library\n * is used to facilitate the switch from the server view to the client view. Specifically that\n * means:\n *\n *    1. Replay stored server view events on client view\n *    2. Switch buffer from server view to client view\n *    3. Reset focus on client view\n */\n\"use strict\";\n// the idea here is that preboot is a global value on the window that is used by the client\nvar preboot = prebootClient();\n// wrapper function used to contain all the preboot client functionality\nfunction prebootClient() {\n    // used to cache map from server node key to associated client node\n    var clientNodeCache = {};\n    /**\n     * External code call this to kick off the switch from server to client\n     */\n    function complete(opts) {\n        opts = opts || {};\n        var theWindow = (opts.window || window);\n        var prebootData = theWindow.prebootData || {};\n        var apps = prebootData.apps || [];\n        // loop through each of the preboot apps\n        apps.forEach(function (appData) { return completeApp(opts, appData); });\n        // once all events have been replayed and buffers switched, then we cleanup preboot\n        if (!opts.noCleanup) {\n            cleanup(theWindow, prebootData);\n        }\n    }\n    /**\n     * Complete a particular app\n     * @param opts\n     * @param appData\n     */\n    function completeApp(opts, appData) {\n        opts = opts || {};\n        appData = (appData || {});\n        var theWindow = (opts.window || window);\n        var root = (appData.root || {});\n        var events = appData.events || [];\n        // if a specific app root set and it doesn't equal the server selector, then don't do anything\n        if (opts.appRoot && opts.appRoot !== root.serverSelector) {\n            return;\n        }\n        // some client side frameworks (like Angular 1 w UI Router) will replace\n        // elements, so we need to re-get client root just to be safe\n        root.clientNode = theWindow.document.querySelector(root.clientSelector);\n        // replay all the events from the server view onto the client view\n        events.forEach(function (event) { return replayEvent(appData, event); });\n        // if we are buffering, switch the buffers\n        switchBuffer(theWindow, appData);\n    }\n    /**\n     * Replay a particular event. The trick here is finding the appropriate client\n     * node where the event is to be dispatched that matches up with the server node\n     * where the event came from originally.\n     */\n    function replayEvent(appData, prebootEvent) {\n        appData = (appData || {});\n        prebootEvent = (prebootEvent || {});\n        var event = prebootEvent.event;\n        var serverNode = prebootEvent.node || {};\n        var nodeKey = prebootEvent.nodeKey;\n        var clientNode = findClientNode({\n            root: appData.root,\n            node: serverNode,\n            nodeKey: nodeKey\n        });\n        // if client node can't be found, log a warning\n        if (!clientNode) {\n            console.warn('Trying to dispatch event ' + event.type +\n                ' to node ' + nodeKey + ' but could not find client node. ' +\n                'Server node is: ');\n            console.log(serverNode);\n            return;\n        }\n        // now dispatch events and whatnot to the client node\n        clientNode.checked = serverNode.checked ? true : undefined;\n        clientNode.selected = serverNode.selected ? true : undefined;\n        clientNode.value = serverNode.value;\n        clientNode.dispatchEvent(event);\n    }\n    /**\n     * Hide the server buffer and show the client buffer\n     */\n    function switchBuffer(window, appData) {\n        appData = (appData || {});\n        var root = (appData.root || {});\n        var serverView = root.serverNode;\n        var clientView = root.clientNode;\n        // if no client view or the server view is the body or client\n        // and server view are the same, then don't do anything and return\n        if (!clientView || !serverView || serverView === clientView || serverView.nodeName === 'BODY') {\n            return;\n        }\n        // do a try-catch for case where serverView is an object but NOT of type Element\n        try {\n            // get the server view display mode\n            var display = window\n                .getComputedStyle(serverView)\n                .getPropertyValue('display') || 'block';\n            // first remove the server view\n            serverView.remove ?\n                serverView.remove() :\n                serverView.style.display = 'none';\n            // now add the client view\n            clientView.style.display = display;\n        }\n        catch (ex) {\n            console.error(ex);\n        }\n    }\n    /**\n     * This function does three things to cleanup preboot:\n     *    1. Set focus (and selection if a text box/text area) within a form element\n     *    2. Remove existing event listeners\n     *    3. Delete data from memory\n     */\n    function cleanup(window, prebootData) {\n        prebootData = prebootData || {};\n        var listeners = prebootData.listeners || [];\n        // set focus on the active node AFTER a small delay to ensure buffer switched\n        setTimeout(function () {\n            setFocus(prebootData.activeNode);\n        }, 1);\n        // remove all event listeners\n        for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {\n            var listener = listeners_1[_i];\n            listener.node.removeEventListener(listener.eventName, listener.handler);\n        }\n        // remove the freeze overlay if it exists\n        removeOverlay(window);\n        // finally clear out the data stored for each app\n        prebootData.apps = [];\n        clientNodeCache = {};\n    }\n    /**\n     * Remove the overlay if it exists\n     */\n    function removeOverlay(window) {\n        var prebootOverlay = window.document.body.querySelector('#prebootOverlay');\n        if (prebootOverlay) {\n            prebootOverlay.style.display = 'none';\n        }\n    }\n    /**\n     * Set focus on a given active node element\n     */\n    function setFocus(activeNode) {\n        // only do something if there is an active node\n        if (!activeNode || !activeNode.node || !activeNode.nodeKey) {\n            return;\n        }\n        // find the client node in the new client view\n        var clientNode = findClientNode(activeNode);\n        if (clientNode) {\n            // set focus on the client node\n            clientNode.focus();\n            // set selection if a modern browser (i.e. IE9+, etc.)\n            var selection = activeNode.selection;\n            if (clientNode.setSelectionRange && selection) {\n                clientNode.setSelectionRange(selection.start, selection.end, selection.direction);\n            }\n        }\n    }\n    /**\n     * Given a node from the server rendered view, find the equivalent\n     * node in the client rendered view. We do this by the following approach:\n     *      1. take the name of the server node tag (ex. div or h1 or input)\n     *      2. add either id (ex. div#myid) or class names (ex. div.class1.class2)\n     *      3. use that value as a selector to get all the matching client nodes\n     *      4. loop through all client nodes found and for each generate a key value\n     *      5. compare the client key to the server key; once there is a match, we have our client node\n     *\n     * NOTE: this only works when the client view is almost exactly the same as the server\n     * view. we will need an improvement here in the future to account for situations\n     * where the client view is different in structure from the server view\n     */\n    function findClientNode(serverNodeContext) {\n        serverNodeContext = (serverNodeContext || {});\n        var serverNode = serverNodeContext.node;\n        var root = serverNodeContext.root;\n        // if no server or client root, don't do anything\n        if (!root || !root.serverNode || !root.clientNode) {\n            return null;\n        }\n        // we use the string of the node to compare to the client node & as key in cache\n        var serverNodeKey = serverNodeContext.nodeKey || getNodeKey(serverNodeContext);\n        // if client node already in cache, return it\n        if (clientNodeCache[serverNodeKey]) {\n            return clientNodeCache[serverNodeKey];\n        }\n        // get the selector for client nodes\n        var className = (serverNode.className || '').replace('ng-binding', '').trim();\n        var selector = serverNode.tagName;\n        if (serverNode.id) {\n            selector += '#' + serverNode.id;\n        }\n        else if (className) {\n            selector += '.' + className.replace(/ /g, '.');\n        }\n        // select all possible client nodes and look through them to try and find a match\n        var rootClientNode = root.clientNode;\n        var clientNodes = rootClientNode.querySelectorAll(selector) || [];\n        // if nothing found, then just try the tag name as a final option\n        if (!clientNodes.length) {\n            clientNodes = rootClientNode.querySelectorAll(serverNode.tagName) || [];\n        }\n        for (var _i = 0, clientNodes_1 = clientNodes; _i < clientNodes_1.length; _i++) {\n            var clientNode = clientNodes_1[_i];\n            // get the key for the client node\n            var clientNodeKey = getNodeKey({ root: root, node: clientNode });\n            // if the client node key is exact match for the server node key, then we found the client node\n            if (clientNodeKey === serverNodeKey) {\n                clientNodeCache[serverNodeKey] = clientNode;\n                return clientNode;\n            }\n        }\n        // if we get here and there is one clientNode, use it as a fallback\n        if (clientNodes.length === 1) {\n            clientNodeCache[serverNodeKey] = clientNodes[0];\n            return clientNodes[0];\n        }\n        // if we get here it means we couldn't find the client node so give the user a warning\n        console.warn('No matching client node found for ' + serverNodeKey +\n            '. You can fix this by assigning this element a unique id attribute.');\n        return null;\n    }\n    /**\n     * Attempt to generate key from node position in the DOM\n     *\n     * NOTE: this function is duplicated in preboot_inline.ts and must be\n     * kept in sync. It is duplicated for right now since we are trying\n     * to keep all inline code separated and distinct (i.e. without imports)\n     */\n    function getNodeKey(nodeContext) {\n        var ancestors = [];\n        var root = nodeContext.root;\n        var node = nodeContext.node;\n        var temp = node;\n        // walk up the tree from the target node up to the root\n        while (temp && temp !== root.serverNode && temp !== root.clientNode) {\n            ancestors.push(temp);\n            temp = temp.parentNode;\n        }\n        // note: if temp doesn't exist here it means root node wasn't found\n        if (temp) {\n            ancestors.push(temp);\n        }\n        // now go backwards starting from the root, appending the appName to unique identify the node later..\n        var name = node.nodeName || 'unknown';\n        var key = name + '_' + root.serverSelector;\n        var len = ancestors.length;\n        for (var i = (len - 1); i >= 0; i--) {\n            temp = ancestors[i];\n            if (temp.childNodes && i > 0) {\n                for (var j = 0; j < temp.childNodes.length; j++) {\n                    if (temp.childNodes[j] === ancestors[i - 1]) {\n                        key += '_s' + (j + 1);\n                        break;\n                    }\n                }\n            }\n        }\n        return key;\n    }\n    return {\n        complete: complete,\n        completeApp: completeApp,\n        replayEvent: replayEvent,\n        switchBuffer: switchBuffer,\n        removeOverlay: removeOverlay,\n        cleanup: cleanup,\n        setFocus: setFocus,\n        findClientNode: findClientNode,\n        getNodeKey: getNodeKey\n    };\n}\nexports.prebootClient = prebootClient;\n","/home/travis/build/npmtest/node-npmtest-preboot/node_modules/preboot/gulpfile.js":"var gulp = require('gulp');\nvar path = require('path');\nvar fs = require('fs');\nvar rootDir = __dirname;\n\n// config values passed into every gulp task file\nvar buildConfig = {\n  rootDir: rootDir,\n  tsFiles: ['src/**/*.ts', 'test/**/*.ts'],\n  testFiles: 'dist/test/**/*_spec.js',\n  distDir: path.join(rootDir, 'dist'),\n  prebootBrowser: path.join(rootDir, 'dist/src/browser/preboot_browser'),\n  prebootNode: path.join(rootDir, 'dist/src/node/preboot_node')\n};\n\n// dynamically load in all the build task files\nvar buildtasksDir = path.join(buildConfig.rootDir, 'buildtasks');\nvar buildtaskFiles = fs.readdirSync(buildtasksDir) || [];\nbuildtaskFiles.forEach(function (buildtaskFile) {\n  var buildtaskPath = path.join(buildtasksDir, buildtaskFile);\n  var buildtask = require(buildtaskPath);\n  buildtask(buildConfig);\n});\n"}